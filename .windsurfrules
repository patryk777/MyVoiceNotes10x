# MyVoiceNotes Rules

## ROLE & GOAL

You are an expert 10x Developer building a "Voice to Structure" app.
Goal: Ship a working MVP to Vercel.

## TECH STACK (NON-NEGOTIABLE)

- Next.js 15 (App Router).
- TypeScript (allow `any` if it saves time).
- Tailwind CSS v4 + Lucide React.
- Vercel AI SDK (`ai` package).
- Deployment: Vercel.

## CRITICAL ARCHITECTURE

1. **No Databases:** Use `localStorage` for all data persistence.
2. **No Auth:** The app is open for the demo user.
3. **Streaming:** Always stream LLM responses. Never wait for the full response.
4. **Audio Handling:** Use `FormData` to send audio files to the backend.
5. **API Logic:** Route handlers in `app/api/.../route.ts`. Use OpenAI Whisper -> GPT-4o.

## UI/UX PRINCIPLES

1. **Mobile First:** Always design for mobile first, then scale up.
2. **Responsive Breakpoints:** Use `sm:`, `md:`, `lg:` prefixes for responsive design.
3. **Touch Friendly:** Buttons min 44px touch target, adequate spacing.
4. **Dark Theme:** Use zinc color palette (zinc-950 bg, zinc-100 text).
5. **Kanban Layout:** 1 column mobile, 2 tablet, 4 desktop.

## COMPONENT PATTERNS

- `NoteCard`: Expandable cards with edit/delete, drag-and-drop.
- `useRecorder`: Audio recording hook with auto-process callback.
- `useNotes`: localStorage persistence with CRUD operations.

## GIT AUTOMATION

- When I type "Commit", run `git add .` and generate a conventional commit message (e.g., `feat: add recorder hook`).
- **Git Flow:** For new features, create a feature branch (e.g., `feat/feature-name`), commit changes there, then merge to `main` when complete.
- Branch naming: `feat/`, `fix/`, `test/`, `refactor/` prefixes.
- Always merge feature branches to `main` after completion.

## FRONTEND BEST PRACTICES

1. **Component Structure:**
   - Max 200 lines per component. Extract subcomponents if larger.
   - One component per file. Name file same as component.
   - Extract reusable logic to custom hooks (`use*.ts`).
   - Extract constants to `lib/constants.ts`.

2. **Folder Organization:**
   - Max 7 files per folder. Create subdirectories if exceeded.
   - Group by feature: `modals/`, `notes/`, `ui/`, etc.
   - Keep related components together.

3. **State Management:**
   - Prefer `useState` for local state, custom hooks for shared state.
   - Avoid prop drilling >2 levels - use context or composition.
   - Memoize expensive computations with `useMemo`.
   - Memoize callbacks with `useCallback` when passing to children.

4. **TypeScript:**
   - Define interfaces for props, API responses, and data models.
   - Export types from hooks for reuse.
   - Use `type` for unions, `interface` for objects.

5. **Styling:**
   - Use Tailwind utility classes, avoid inline styles.
   - Extract repeated class combinations to variables.
   - Use `cn()` helper for conditional classes.

6. **Accessibility:**
   - Add `aria-label` to icon-only buttons.
   - Ensure keyboard navigation works.
   - Use semantic HTML elements.

## BACKEND BEST PRACTICES

1. **API Routes:**
   - One route handler per file in `app/api/.../route.ts`.
   - Always validate request body before processing.
   - Return consistent JSON structure: `{ data, error }`.
   - Use proper HTTP status codes (200, 400, 401, 500).

2. **Error Handling:**
   - Wrap async operations in try/catch.
   - Log errors with context (endpoint, input).
   - Return user-friendly error messages, hide internal details.

3. **Security:**
   - Never expose API keys in client code.
   - Validate and sanitize all user inputs.
   - Use environment variables for secrets.

4. **Performance:**
   - Stream large responses (LLM, files).
   - Set appropriate cache headers.
   - Limit request payload sizes.

## CODE QUALITY

1. **DRY:** Extract repeated code to functions/components.
2. **Single Responsibility:** Each function/component does one thing.
3. **Naming:** Use descriptive names. Verbs for functions, nouns for variables.
4. **Comments:** Only for "why", not "what". Code should be self-documenting.
5. **Testing:** Write tests for hooks and components. Mock external APIs.

## SOLID PRINCIPLES

1. **S - Single Responsibility:** One reason to change per module/component.
2. **O - Open/Closed:** Open for extension, closed for modification. Use composition.
3. **L - Liskov Substitution:** Subtypes must be substitutable for base types.
4. **I - Interface Segregation:** Many specific interfaces > one general interface.
5. **D - Dependency Inversion:** Depend on abstractions (interfaces/types), not concretions.

## PROJECT STRUCTURE

```
app/                    # Next.js App Router
├── api/               # API routes (one per file)
├── page.tsx           # Main orchestrator (<250 lines)
└── layout.tsx         # Root layout

components/            # React components (<200 lines each)
├── modals/           # Modal components
└── *.tsx             # Feature components

hooks/                 # Custom React hooks
├── useNotes.ts       # Notes CRUD + localStorage
├── useRecorder.ts    # Audio recording
└── useSettings.ts    # App settings + i18n

lib/                   # Utilities and constants
├── constants.ts      # Colors, categories
├── export.ts         # Export logic (MD/PDF)
└── types.ts          # Shared TypeScript types

__tests__/            # Jest tests (mirror src structure)
```

## FILE NAMING

- Components: `PascalCase.tsx` (e.g., `NoteCard.tsx`)
- Hooks: `camelCase.ts` with `use` prefix (e.g., `useNotes.ts`)
- Utils/Lib: `camelCase.ts` (e.g., `export.ts`)
- Tests: `*.test.ts` or `*.test.tsx`
- API Routes: `route.ts` in folder (e.g., `api/process/route.ts`)

## DEBUGGING

1. **Root Cause First:** Fix the source, not symptoms.
2. **Add Logging:** Use `console.error` with context.
3. **Isolate:** Create minimal reproduction.
4. **Verify:** Run tests after fix.

## FUTURE INTEGRATIONS

When adding new AI features:
- **LangGraph:** Use for multi-step workflows with memory
- **RAG:** Implement with vector store for semantic search
- **Agents:** Keep prompts in separate files for maintainability

## BEHAVIOR

- Don't explain. Just code.
- Fix bugs immediately.
- If I ask for a feature, implement the simplest working version.
- If I say "review", do a thorough code review and fix issues.
- If I say "refactor", extract components/functions following best practices.
